---- OTWARTE ----
TODO poprawić te konwersje w wysyłaniu w przypadku helloreply
0. Co z tym addr_len?
1.1.1. Co jeśli drugi raz dodajemy ten sam węzeł? (Sprawdzić treść oraz discorda) TO JEST NA DISCORDZIE, ZGLEBIC
1.1.2.1 Co jeśli u starego węzła nie starcza miejsca na nowego? Problem jest też taki, że establish_connection u starego robimy na końcu handle_hello.
1.2. Posprzątać!
1.2.1. Dodać consty
1.2.2. Na wszelki zapisać globalnie swoj adres oraz port
1.2.3. Globalny czy lokalny bufor?
1.2.4. Być może po prostu tablica rozmiaru ~65k na znane węzły?
1.2.5. Skoro (a propos Message) "Wartości w binarnych polach wielooktetowych zapisuje się w porządku sieciowym.", to czy nie mamy/lepiej ich w sumie stale mieć w porządku sieciowym?
1.2.6. W msg_send (i inncyh funkcjach tego typu) powinniśmy być moze tworzyc kopie msg i konwertowac i przesylac kopię dla swiętego spokoju
2. Jak nie przekroczyć czasu oczekiwania?
3. Jaki ma być MAX_DATA? Co jeśli nie starczy pamięci?
5. Zamienić funkcję get_peer_address na taką, która przyjmuje wskaźnik do struct sockaddr_in, a nie zwraca te strukture.
6. Zamykanie gniazda w przypadku błędu.
7. uint8_t czy unsigned char?
9. Sprawdzić wszystkie inet_*, w szczególności inet_pton i konwertowanie tych adresów do różnych form
10. W sumie to te makra można zamienić na enum.
11. Spoofing

NA KONIEC
1. Modularność - biblioteki.
2. Klasy i structy i fajność, jedność.
3. Można by zrobić bardziej ogólny struct Message.
    I znowu byłby HelloMessage, HelloReplyMessage itd,
    Ale w tej strukturze byłoby coś więcej:
        - struktura do przesyłania danych przez internet (obecny Message)
        - Funkcja do obsługi komunikatu
        - Rozmiar komunikatu (ale to jest static)
        - Nazwa komunikatu (to też static)
        - Taka po prostu klasa

NOTATKI
1. Aktualnie "zaniedbujemy" g_buf: nie zerujemy go przed read-em, nie ustawiamy koncowych bajtow na 0.

---- ROZWIĄZANE ----
1. Rozdzielamy HELLO REPLY na dwa komunikaty?
    ODP: Nie, nielegalne
2. (Tutaj chodzi o ack_connect) Czy receive_reply jest poprawne: W sensie tam oczekujemy tylko i wyłącznie na HELLO_REPLY, to nienajlepsze? Co robić z innymi komunikatami, które mogą przyjść w międzyczasie? Czy mogą?
    ODP: Nie możemy oczekiwać wyłącznie na ACK_CONNECT, bo już połączone węzły moga wysyłać jakieś inne komunikaty
3. Czy jeśli _ar_provided, to czy ten węzeł też jest znajomym nowego węzła?
    ODP: Mnie się wydaje, że tak, w końcu w treści napisane jest, że te węzły "nawiązały komunikację". Ale dla pewności można sprawdzić discorda.
4. Jak sprawdzać dane podane na wejściu, szczególnie adresy. Z jednej strony przy pierwszej próbie nawiazania polaczenia funkcja sie wywali, z drugiej czy nie powinnismy o tym wiedziec zawczasu?
    ODP: Peczarski pisze, że poprawność sprawdzi funkcja wysyłająca
0.1. Jak w końcu to HELLO_REPLY, jak z innymi? Czy zrobić jakąś klasę i podklasy, tak jak we Futureach? TAK
        - nie miec PeerMessage, to bedzei po prostu w Peer DONE
1.1.2 Połączyć te pierwsze węzły DONE


